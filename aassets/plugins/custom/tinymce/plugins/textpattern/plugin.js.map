{"version":3,"sources":["textpattern/plugin.js"],"names":["domGlobals","Cell","initial","value","get","set","v","clone","global","tinymce","util","Tools","resolve","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","eq","id","me","noop","constant","identity","x","never","always","none","NONE","o","isNone","fold","is","isSome","getOr","getOrThunk","thunk","getOrDie","msg","Error","getOrNull","getOrUndefined","undefined","or","orThunk","map","each","bind","exists","forall","filter","equals","equals_","toArray","toString","freeze","some","a","constant_a","self","f","elementEq","b","Option","from","isType","type","Array","isPrototypeOf","constructor","name","String","typeOf","isString","isObject","isArray","isFunction","nativeSlice","slice","nativeIndexOf","indexOf","contains","xs","ts","len","r","pred","push","foldr","acc","eachr","keys","has","obj","key","Adt","cases","constructors","adt","acase","count","keys$1","argLength","args","match","branches","branchKeys","join","reqKey","log","label","console","params","partition","bothErrors","firstError","secondError","bothValues","results","errors","values","result","err","isValue","isError","opt","_","onValue","mapError","toOption","error","message","onError","Result","fromOption","isInlinePattern","pattern","isBlockPattern","sortPatterns","patterns","comparator","start","copy","sort","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","end","start_1","end_1","replacement","command","commandValue","denormalizePattern","createPatternSet","inlinePatterns","blockPatterns","Api","patternsState","setPatterns","newPatterns","normalized","JSON","stringify","getPatterns","il","k","j","jl","__spreadArrays","Global","window","Function","error$1","_i","defaultPatterns","getPatternSet","editorSettings","getForcedRootBlock","editor","block","getParam","global$1","global$2","global$3","global$4","isText","node","nodeType","Node","TEXT_NODE","cleanEmptyNodes","dom","isRoot","isEmpty","parent","parentNode","remove","deleteRng","rng","clean","startParent","startContainer","endParent","endContainer","deleteContents","data","isBlockFormatName","formatter","formatSet","isReplacementPattern","findPattern","text","find","isInlinePattern$1","lastIndexOf","getParentBlock","parentBlockOpt","getParent","isBlock","getBody","point","element","offset","TextWalker","startNode","rootNode","walker","walk","direction","next","prev","prev2","textBefore","scanLeft","textContent","prevText","scanRight","outcome","aborted","edge","success","phase","abort","kontinue","finish","repeat","process","recent","terminate","recurse","nodeName","getContentEditable","isBoundary","generatePath","root","current","childNodes","reverse","generatePathRange","startOffset","endNode","endOffset","resolvePath","path","nodePath","pop","optNode","index","resolvePathRange","range","_a","document","createRange","setStart","setEnd","stripPattern","createRng","e","applyMatches","matches","bookmark","selection","getBookmark","getRoot","undoManager","transact","execCommand","applyPattern","moveToBookmark","unique","newMarker","create","data-mce-type","rangeFromMarker","marker","setStartAfter","setEndBefore","createMarker","markerPrefix","pathRange","textEnd","splitText","textStart","prefix","insertBefore","removeMarker","findPatternStart","requireGap","spot","repeatLeft","content","optOffset","searchText","substring","startEndIndex","charAt","startIndex","nodeMatchesPattern","startRange","findPattern$1","details","position","endPathRng","startRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","results_1","pos","startPathRng","generatePathRangeFromRange","concat","endSpot","str","suffix","substr","checkRange","patternsWithoutCurrent","splice","applyPattern$1","patternRange","setRng","addMarkers","time","Date","getTime","Math","floor","random","matchesWithEnds","endMarker","idx","startMarker","findPatterns$1","space","getRng","collapsed","applyMatches$1","matchesWithMarkers","markerRange","applyReplacementPattern","markerEndRange","markerStartRange","patternMarker","applyPatternWithContent","checkKeyEvent","codes","event","predicate","KeyHandler","patternSet","isCollapsed","inlineMatches","blockMatches","forcedRootBlock","matchesForcedRootBlock","blockText","trim","findPatterns","add","extra","insertContent","deleteData","chars","chr","charCodeAt","charCode","code","keyCode","modifierPressed","Keyboard","setup","charCodes","keyCodes","on","preventDefault","setEditorTimeout","settings"],"mappings":"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","file":"plugin.js","sourcesContent":["/**\n * Copyright (c) Tiny Technologies, Inc. All rights reserved.\n * Licensed under the LGPL or a commercial license.\n * For LGPL see License.txt in the project root for license information.\n * For commercial licenses see https://www.tiny.cloud/\n *\n * Version: 5.1.0 (2019-10-17)\n */\n(function (domGlobals) {\n    'use strict';\n\n    var Cell = function (initial) {\n      var value = initial;\n      var get = function () {\n        return value;\n      };\n      var set = function (v) {\n        value = v;\n      };\n      var clone = function () {\n        return Cell(get());\n      };\n      return {\n        get: get,\n        set: set,\n        clone: clone\n      };\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var __assign = function () {\n      __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n    function __spreadArrays() {\n      for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n        s += arguments[i].length;\n      for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n      return r;\n    }\n\n    var noop = function () {\n    };\n    var constant = function (value) {\n      return function () {\n        return value;\n      };\n    };\n    var identity = function (x) {\n      return x;\n    };\n    var die = function (msg) {\n      return function () {\n        throw new Error(msg);\n      };\n    };\n    var never = constant(false);\n    var always = constant(true);\n\n    var none = function () {\n      return NONE;\n    };\n    var NONE = function () {\n      var eq = function (o) {\n        return o.isNone();\n      };\n      var call = function (thunk) {\n        return thunk();\n      };\n      var id = function (n) {\n        return n;\n      };\n      var me = {\n        fold: function (n, s) {\n          return n();\n        },\n        is: never,\n        isSome: never,\n        isNone: always,\n        getOr: id,\n        getOrThunk: call,\n        getOrDie: function (msg) {\n          throw new Error(msg || 'error: getOrDie called on none.');\n        },\n        getOrNull: constant(null),\n        getOrUndefined: constant(undefined),\n        or: id,\n        orThunk: call,\n        map: none,\n        each: noop,\n        bind: none,\n        exists: never,\n        forall: always,\n        filter: none,\n        equals: eq,\n        equals_: eq,\n        toArray: function () {\n          return [];\n        },\n        toString: constant('none()')\n      };\n      if (Object.freeze) {\n        Object.freeze(me);\n      }\n      return me;\n    }();\n    var some = function (a) {\n      var constant_a = constant(a);\n      var self = function () {\n        return me;\n      };\n      var bind = function (f) {\n        return f(a);\n      };\n      var me = {\n        fold: function (n, s) {\n          return s(a);\n        },\n        is: function (v) {\n          return a === v;\n        },\n        isSome: always,\n        isNone: never,\n        getOr: constant_a,\n        getOrThunk: constant_a,\n        getOrDie: constant_a,\n        getOrNull: constant_a,\n        getOrUndefined: constant_a,\n        or: self,\n        orThunk: self,\n        map: function (f) {\n          return some(f(a));\n        },\n        each: function (f) {\n          f(a);\n        },\n        bind: bind,\n        exists: bind,\n        forall: bind,\n        filter: function (f) {\n          return f(a) ? me : NONE;\n        },\n        toArray: function () {\n          return [a];\n        },\n        toString: function () {\n          return 'some(' + a + ')';\n        },\n        equals: function (o) {\n          return o.is(a);\n        },\n        equals_: function (o, elementEq) {\n          return o.fold(never, function (b) {\n            return elementEq(a, b);\n          });\n        }\n      };\n      return me;\n    };\n    var from = function (value) {\n      return value === null || value === undefined ? NONE : some(value);\n    };\n    var Option = {\n      some: some,\n      none: none,\n      from: from\n    };\n\n    var typeOf = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isType = function (type) {\n      return function (value) {\n        return typeOf(value) === type;\n      };\n    };\n    var isString = isType('string');\n    var isObject = isType('object');\n    var isArray = isType('array');\n    var isFunction = isType('function');\n\n    var nativeSlice = Array.prototype.slice;\n    var nativeIndexOf = Array.prototype.indexOf;\n    var rawIndexOf = function (ts, t) {\n      return nativeIndexOf.call(ts, t);\n    };\n    var contains = function (xs, x) {\n      return rawIndexOf(xs, x) > -1;\n    };\n    var map = function (xs, f) {\n      var len = xs.length;\n      var r = new Array(len);\n      for (var i = 0; i < len; i++) {\n        var x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    var each = function (xs, f) {\n      for (var i = 0, len = xs.length; i < len; i++) {\n        var x = xs[i];\n        f(x, i);\n      }\n    };\n    var eachr = function (xs, f) {\n      for (var i = xs.length - 1; i >= 0; i--) {\n        var x = xs[i];\n        f(x, i);\n      }\n    };\n    var filter = function (xs, pred) {\n      var r = [];\n      for (var i = 0, len = xs.length; i < len; i++) {\n        var x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    var foldr = function (xs, f, acc) {\n      eachr(xs, function (x) {\n        acc = f(acc, x);\n      });\n      return acc;\n    };\n    var foldl = function (xs, f, acc) {\n      each(xs, function (x) {\n        acc = f(acc, x);\n      });\n      return acc;\n    };\n    var find = function (xs, pred) {\n      for (var i = 0, len = xs.length; i < len; i++) {\n        var x = xs[i];\n        if (pred(x, i)) {\n          return Option.some(x);\n        }\n      }\n      return Option.none();\n    };\n    var forall = function (xs, pred) {\n      for (var i = 0, len = xs.length; i < len; ++i) {\n        var x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    var sort = function (xs, comparator) {\n      var copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    var head = function (xs) {\n      return xs.length === 0 ? Option.none() : Option.some(xs[0]);\n    };\n    var from$1 = isFunction(Array.from) ? Array.from : function (x) {\n      return nativeSlice.call(x);\n    };\n\n    var keys = Object.keys;\n    var hasOwnProperty = Object.hasOwnProperty;\n    var get = function (obj, key) {\n      return has(obj, key) ? Option.from(obj[key]) : Option.none();\n    };\n    var has = function (obj, key) {\n      return hasOwnProperty.call(obj, key);\n    };\n\n    var generate = function (cases) {\n      if (!isArray(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      var constructors = [];\n      var adt = {};\n      each(cases, function (acase, count) {\n        var keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        var key = keys$1[0];\n        var value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = function () {\n          var argLength = arguments.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          var args = new Array(argLength);\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n          var match = function (branches) {\n            var branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            var allReqd = forall(constructors, function (reqKey) {\n              return contains(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: function () {\n              if (arguments.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + arguments.length);\n              }\n              var target = arguments[count];\n              return target.apply(null, args);\n            },\n            match: match,\n            log: function (label) {\n              domGlobals.console.log(label, {\n                constructors: constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    var Adt = { generate: generate };\n\n    var comparison = Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    var partition = function (results) {\n      var errors = [];\n      var values = [];\n      each(results, function (result) {\n        result.fold(function (err) {\n          errors.push(err);\n        }, function (value) {\n          values.push(value);\n        });\n      });\n      return {\n        errors: errors,\n        values: values\n      };\n    };\n\n    var value = function (o) {\n      var is = function (v) {\n        return o === v;\n      };\n      var or = function (opt) {\n        return value(o);\n      };\n      var orThunk = function (f) {\n        return value(o);\n      };\n      var map = function (f) {\n        return value(f(o));\n      };\n      var mapError = function (f) {\n        return value(o);\n      };\n      var each = function (f) {\n        f(o);\n      };\n      var bind = function (f) {\n        return f(o);\n      };\n      var fold = function (_, onValue) {\n        return onValue(o);\n      };\n      var exists = function (f) {\n        return f(o);\n      };\n      var forall = function (f) {\n        return f(o);\n      };\n      var toOption = function () {\n        return Option.some(o);\n      };\n      return {\n        is: is,\n        isValue: always,\n        isError: never,\n        getOr: constant(o),\n        getOrThunk: constant(o),\n        getOrDie: constant(o),\n        or: or,\n        orThunk: orThunk,\n        fold: fold,\n        map: map,\n        mapError: mapError,\n        each: each,\n        bind: bind,\n        exists: exists,\n        forall: forall,\n        toOption: toOption\n      };\n    };\n    var error = function (message) {\n      var getOrThunk = function (f) {\n        return f();\n      };\n      var getOrDie = function () {\n        return die(String(message))();\n      };\n      var or = function (opt) {\n        return opt;\n      };\n      var orThunk = function (f) {\n        return f();\n      };\n      var map = function (f) {\n        return error(message);\n      };\n      var mapError = function (f) {\n        return error(f(message));\n      };\n      var bind = function (f) {\n        return error(message);\n      };\n      var fold = function (onError, _) {\n        return onError(message);\n      };\n      return {\n        is: never,\n        isValue: never,\n        isError: always,\n        getOr: identity,\n        getOrThunk: getOrThunk,\n        getOrDie: getOrDie,\n        or: or,\n        orThunk: orThunk,\n        fold: fold,\n        map: map,\n        mapError: mapError,\n        each: noop,\n        bind: bind,\n        exists: never,\n        forall: always,\n        toOption: Option.none\n      };\n    };\n    var fromOption = function (opt, err) {\n      return opt.fold(function () {\n        return error(err);\n      }, value);\n    };\n    var Result = {\n      value: value,\n      error: error,\n      fromOption: fromOption\n    };\n\n    var isInlinePattern = function (pattern) {\n      return pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    };\n    var isBlockPattern = function (pattern) {\n      return pattern.type === 'block-command' || pattern.type === 'block-format';\n    };\n    var sortPatterns = function (patterns) {\n      return sort(patterns, function (a, b) {\n        if (a.start.length === b.start.length) {\n          return 0;\n        }\n        return a.start.length > b.start.length ? -1 : 1;\n      });\n    };\n    var normalizePattern = function (pattern) {\n      var err = function (message) {\n        return Result.error({\n          message: message,\n          pattern: pattern\n        });\n      };\n      var formatOrCmd = function (name, onFormat, onCommand) {\n        if (pattern.format !== undefined) {\n          var formats = void 0;\n          if (isArray(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        var start_1 = pattern.start;\n        var end_1 = pattern.end;\n        if (end_1.length === 0) {\n          end_1 = start_1;\n          start_1 = '';\n        }\n        return formatOrCmd('Inline', function (format) {\n          return {\n            type: 'inline-format',\n            start: start_1,\n            end: end_1,\n            format: format\n          };\n        }, function (cmd, value) {\n          return {\n            type: 'inline-command',\n            start: start_1,\n            end: end_1,\n            cmd: cmd,\n            value: value\n          };\n        });\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', function (formats) {\n          return {\n            type: 'block-format',\n            start: pattern.start,\n            format: formats[0]\n          };\n        }, function (command, commandValue) {\n          return {\n            type: 'block-command',\n            start: pattern.start,\n            cmd: command,\n            value: commandValue\n          };\n        });\n      }\n    };\n    var denormalizePattern = function (pattern) {\n      if (pattern.type === 'block-command') {\n        return {\n          start: pattern.start,\n          cmd: pattern.cmd,\n          value: pattern.value\n        };\n      } else if (pattern.type === 'block-format') {\n        return {\n          start: pattern.start,\n          format: pattern.format\n        };\n      } else if (pattern.type === 'inline-command') {\n        if (pattern.cmd === 'mceInsertContent' && pattern.start === '') {\n          return {\n            start: pattern.end,\n            replacement: pattern.value\n          };\n        } else {\n          return {\n            start: pattern.start,\n            end: pattern.end,\n            cmd: pattern.cmd,\n            value: pattern.value\n          };\n        }\n      } else if (pattern.type === 'inline-format') {\n        return {\n          start: pattern.start,\n          end: pattern.end,\n          format: pattern.format.length === 1 ? pattern.format[0] : pattern.format\n        };\n      }\n    };\n    var createPatternSet = function (patterns) {\n      return {\n        inlinePatterns: filter(patterns, isInlinePattern),\n        blockPatterns: sortPatterns(filter(patterns, isBlockPattern))\n      };\n    };\n\n    var get$1 = function (patternsState) {\n      var setPatterns = function (newPatterns) {\n        var normalized = partition(map(newPatterns, normalizePattern));\n        if (normalized.errors.length > 0) {\n          var firstError = normalized.errors[0];\n          throw new Error(firstError.message + ':\\n' + JSON.stringify(firstError.pattern, null, 2));\n        }\n        patternsState.set(createPatternSet(normalized.values));\n      };\n      var getPatterns = function () {\n        return __spreadArrays(map(patternsState.get().inlinePatterns, denormalizePattern), map(patternsState.get().blockPatterns, denormalizePattern));\n      };\n      return {\n        setPatterns: setPatterns,\n        getPatterns: getPatterns\n      };\n    };\n    var Api = { get: get$1 };\n\n    var Global = typeof domGlobals.window !== 'undefined' ? domGlobals.window : Function('return this;')();\n\n    var error$1 = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var console = Global.console;\n      if (console) {\n        if (console.error) {\n          console.error.apply(console, args);\n        } else {\n          console.log.apply(console, args);\n        }\n      }\n    };\n    var defaultPatterns = [\n      {\n        start: '*',\n        end: '*',\n        format: 'italic'\n      },\n      {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      },\n      {\n        start: '#',\n        format: 'h1'\n      },\n      {\n        start: '##',\n        format: 'h2'\n      },\n      {\n        start: '###',\n        format: 'h3'\n      },\n      {\n        start: '####',\n        format: 'h4'\n      },\n      {\n        start: '#####',\n        format: 'h5'\n      },\n      {\n        start: '######',\n        format: 'h6'\n      },\n      {\n        start: '1. ',\n        cmd: 'InsertOrderedList'\n      },\n      {\n        start: '* ',\n        cmd: 'InsertUnorderedList'\n      },\n      {\n        start: '- ',\n        cmd: 'InsertUnorderedList'\n      }\n    ];\n    var getPatternSet = function (editorSettings) {\n      var patterns = get(editorSettings, 'textpattern_patterns').getOr(defaultPatterns);\n      if (!isArray(patterns)) {\n        error$1('The setting textpattern_patterns should be an array');\n        return {\n          inlinePatterns: [],\n          blockPatterns: []\n        };\n      }\n      var normalized = partition(map(patterns, normalizePattern));\n      each(normalized.errors, function (err) {\n        return error$1(err.message, err.pattern);\n      });\n      return createPatternSet(normalized.values);\n    };\n    var getForcedRootBlock = function (editor) {\n      var block = editor.getParam('forced_root_block', 'p');\n      if (block === false) {\n        return '';\n      } else if (block === true) {\n        return 'p';\n      } else {\n        return block;\n      }\n    };\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Delay');\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    var zeroWidth = function () {\n      return '\\uFEFF';\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var isText = function (node) {\n      return node.nodeType === domGlobals.Node.TEXT_NODE;\n    };\n    var cleanEmptyNodes = function (dom, node, isRoot) {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        var parent = node.parentNode;\n        dom.remove(node);\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    var deleteRng = function (dom, rng, isRoot, clean) {\n      if (clean === void 0) {\n        clean = true;\n      }\n      var startParent = rng.startContainer.parentNode;\n      var endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    var isBlockFormatName = function (name, formatter) {\n      var formatSet = formatter.get(name);\n      return isArray(formatSet) && head(formatSet).exists(function (format) {\n        return has(format, 'block');\n      });\n    };\n    var isInlinePattern$1 = function (pattern) {\n      return has(pattern, 'end');\n    };\n    var isReplacementPattern = function (pattern) {\n      return pattern.start.length === 0;\n    };\n    var findPattern = function (patterns, text) {\n      return find(patterns, function (pattern) {\n        if (text.indexOf(pattern.start) !== 0) {\n          return false;\n        }\n        if (isInlinePattern$1(pattern) && pattern.end && text.lastIndexOf(pattern.end) !== text.length - pattern.end.length) {\n          return false;\n        }\n        return true;\n      });\n    };\n    var getParentBlock = function (editor, rng) {\n      var parentBlockOpt = Option.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n      if (getForcedRootBlock(editor) === '') {\n        return parentBlockOpt.orThunk(function () {\n          return Option.some(editor.getBody());\n        });\n      } else {\n        return parentBlockOpt;\n      }\n    };\n\n    var point = function (element, offset) {\n      return {\n        element: element,\n        offset: offset\n      };\n    };\n\n    var TextWalker = function (startNode, rootNode) {\n      var walker = new global$4(startNode, rootNode);\n      var walk = function (direction) {\n        var next = walker[direction]();\n        while (next && next.nodeType !== domGlobals.Node.TEXT_NODE) {\n          next = walker[direction]();\n        }\n        return next && next.nodeType === domGlobals.Node.TEXT_NODE ? Option.some(next) : Option.none();\n      };\n      return {\n        next: function () {\n          return walk('next');\n        },\n        prev: function () {\n          return walk('prev');\n        },\n        prev2: function () {\n          return walk('prev2');\n        }\n      };\n    };\n\n    var textBefore = function (node, offset, rootNode) {\n      if (isText(node) && offset >= 0) {\n        return Option.some(point(node, offset));\n      } else {\n        var textWalker = TextWalker(node, rootNode);\n        return textWalker.prev().map(function (prev) {\n          return point(prev, prev.data.length);\n        });\n      }\n    };\n    var scanLeft = function (node, offset, rootNode) {\n      if (!isText(node)) {\n        return Option.none();\n      }\n      var text = node.textContent;\n      if (offset >= 0 && offset <= text.length) {\n        return Option.some(point(node, offset));\n      } else {\n        var textWalker = TextWalker(node, rootNode);\n        return textWalker.prev().bind(function (prev) {\n          var prevText = prev.textContent;\n          return scanLeft(prev, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    var scanRight = function (node, offset, rootNode) {\n      if (!isText(node)) {\n        return Option.none();\n      }\n      var text = node.textContent;\n      if (offset <= text.length) {\n        return Option.some(point(node, offset));\n      } else {\n        var textWalker = TextWalker(node, rootNode);\n        return textWalker.next().bind(function (next) {\n          return scanRight(next, offset - text.length, rootNode);\n        });\n      }\n    };\n    var isBoundary = function (dom, node) {\n      return dom.isBlock(node) || contains([\n        'BR',\n        'IMG',\n        'HR',\n        'INPUT'\n      ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    };\n    var outcome = Adt.generate([\n      { aborted: [] },\n      { edge: ['element'] },\n      { success: ['info'] }\n    ]);\n    var phase = Adt.generate([\n      { abort: [] },\n      { kontinue: [] },\n      { finish: ['info'] }\n    ]);\n    var repeat = function (dom, node, offset, process, walker, recent) {\n      var terminate = function () {\n        return recent.fold(outcome.aborted, outcome.edge);\n      };\n      var recurse = function () {\n        var next = walker();\n        if (next) {\n          return repeat(dom, next, Option.none(), process, walker, Option.some(node));\n        } else {\n          return terminate();\n        }\n      };\n      if (isBoundary(dom, node)) {\n        return terminate();\n      } else if (!isText(node)) {\n        return recurse();\n      } else {\n        var text = node.textContent;\n        return process(phase, node, text, offset).fold(outcome.aborted, function () {\n          return recurse();\n        }, outcome.success);\n      }\n    };\n    var repeatLeft = function (dom, node, offset, process, rootNode) {\n      var walker = new global$4(node, rootNode);\n      return repeat(dom, node, Option.some(offset), process, walker.prev, Option.none());\n    };\n\n    var generatePath = function (root, node, offset) {\n      if (isText(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      var p = [offset];\n      var current = node;\n      while (current !== root && current.parentNode) {\n        var parent = current.parentNode;\n        for (var i = 0; i < parent.childNodes.length; i++) {\n          if (parent.childNodes[i] === current) {\n            p.push(i);\n            break;\n          }\n        }\n        current = parent;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    var generatePathRange = function (root, startNode, startOffset, endNode, endOffset) {\n      var start = generatePath(root, startNode, startOffset);\n      var end = generatePath(root, endNode, endOffset);\n      return {\n        start: start,\n        end: end\n      };\n    };\n    var resolvePath = function (root, path) {\n      var nodePath = path.slice();\n      var offset = nodePath.pop();\n      return foldl(nodePath, function (optNode, index) {\n        return optNode.bind(function (node) {\n          return Option.from(node.childNodes[index]);\n        });\n      }, Option.some(root)).bind(function (node) {\n        if (isText(node) && offset >= 0 && offset <= node.data.length) {\n          return Option.some({\n            node: node,\n            offset: offset\n          });\n        } else {\n          return Option.some({\n            node: node,\n            offset: offset\n          });\n        }\n      });\n    };\n    var resolvePathRange = function (root, range) {\n      return resolvePath(root, range.start).bind(function (_a) {\n        var startNode = _a.node, startOffset = _a.offset;\n        return resolvePath(root, range.end).map(function (_a) {\n          var endNode = _a.node, endOffset = _a.offset;\n          var rng = domGlobals.document.createRange();\n          rng.setStart(startNode, startOffset);\n          rng.setEnd(endNode, endOffset);\n          return rng;\n        });\n      });\n    };\n    var generatePathRangeFromRange = function (root, range) {\n      return generatePathRange(root, range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n    };\n\n    var stripPattern = function (dom, block, pattern) {\n      var firstTextNode = TextWalker(block, block).next();\n      firstTextNode.each(function (node) {\n        scanRight(node, pattern.start.length, block).each(function (end) {\n          var rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.element, end.offset);\n          deleteRng(dom, rng, function (e) {\n            return e === block;\n          });\n        });\n      });\n    };\n    var applyPattern = function (editor, match) {\n      var dom = editor.dom;\n      var pattern = match.pattern;\n      var rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      getParentBlock(editor, rng).each(function (block) {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(function () {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(function () {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    var findPatterns = function (editor, patterns) {\n      var dom = editor.dom;\n      var rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).filter(function (block) {\n        var forcedRootBlock = getForcedRootBlock(editor);\n        var matchesForcedRootBlock = forcedRootBlock === '' && dom.is(block, 'body') || dom.is(block, forcedRootBlock);\n        return block !== null && matchesForcedRootBlock;\n      }).bind(function (block) {\n        var blockText = block.textContent;\n        var matchedPattern = findPattern(patterns, blockText);\n        return matchedPattern.map(function (pattern) {\n          if (global$3.trim(blockText).length === pattern.start.length) {\n            return [];\n          }\n          return [{\n              pattern: pattern,\n              range: generatePathRange(dom.getRoot(), block, 0, block, 0)\n            }];\n        });\n      }).getOr([]);\n    };\n    var applyMatches = function (editor, matches) {\n      if (matches.length === 0) {\n        return;\n      }\n      var bookmark = editor.selection.getBookmark();\n      each(matches, function (match) {\n        return applyPattern(editor, match);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    var unique = 0;\n    var generate$1 = function (prefix) {\n      var date = new Date();\n      var time = date.getTime();\n      var random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    var checkRange = function (str, substr, start) {\n      if (substr === '') {\n        return true;\n      }\n      if (str.length < substr.length) {\n        return false;\n      }\n      var x = str.substr(start, start + substr.length);\n      return x === substr;\n    };\n    var endsWith = function (str, suffix) {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n\n    var newMarker = function (dom, id) {\n      return dom.create('span', {\n        'data-mce-type': 'bookmark',\n        'id': id\n      });\n    };\n    var rangeFromMarker = function (dom, marker) {\n      var rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    var createMarker = function (dom, markerPrefix, pathRange) {\n      var rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      var startNode = rng.startContainer;\n      var endNode = rng.endContainer;\n      var textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      var textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      return {\n        prefix: markerPrefix,\n        end: textEnd.parentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: textStart.parentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    var removeMarker = function (dom, marker, isRoot) {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    var nodeMatchesPattern = function (dom, block, content) {\n      return function (phase, element, text, optOffset) {\n        if (element === block) {\n          return phase.abort();\n        }\n        var searchText = text.substring(0, optOffset.getOr(text.length));\n        var startEndIndex = searchText.lastIndexOf(content.charAt(content.length - 1));\n        var startIndex = searchText.lastIndexOf(content);\n        if (startIndex !== -1) {\n          var rng = dom.createRng();\n          rng.setStart(element, startIndex);\n          rng.setEnd(element, startIndex + content.length);\n          return phase.finish(rng);\n        } else if (startEndIndex !== -1) {\n          return scanLeft(element, startEndIndex + 1 - content.length, block).fold(function () {\n            return phase.kontinue();\n          }, function (spot) {\n            var rng = dom.createRng();\n            rng.setStart(spot.element, spot.offset);\n            rng.setEnd(element, startEndIndex + 1);\n            if (rng.toString() === content) {\n              return phase.finish(rng);\n            } else {\n              return phase.kontinue();\n            }\n          });\n        } else {\n          return phase.kontinue();\n        }\n      };\n    };\n    var findPatternStart = function (dom, pattern, node, offset, block, requireGap) {\n      if (requireGap === void 0) {\n        requireGap = false;\n      }\n      if (pattern.start.length === 0 && !requireGap) {\n        var rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Option.some(rng);\n      }\n      return textBefore(node, offset, block).bind(function (spot) {\n        var outcome = repeatLeft(dom, spot.element, spot.offset, nodeMatchesPattern(dom, block, pattern.start), block);\n        var start = outcome.fold(Option.none, Option.none, Option.some);\n        return start.bind(function (startRange) {\n          if (requireGap) {\n            if (startRange.endContainer === spot.element && startRange.endOffset === spot.offset) {\n              return Option.none();\n            } else if (spot.offset === 0 && startRange.endContainer.textContent.length === startRange.endOffset) {\n              return Option.none();\n            }\n          }\n          return Option.some(startRange);\n        });\n      });\n    };\n    var findPattern$1 = function (editor, block, details) {\n      var dom = editor.dom;\n      var root = dom.getRoot();\n      var pattern = details.pattern;\n      var endNode = details.position.element;\n      var endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(function (spot) {\n        var endPathRng = generatePathRange(root, spot.element, spot.offset, endNode, endOffset);\n        if (isReplacementPattern(pattern)) {\n          return Option.some({\n            matches: [{\n                pattern: pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          var resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.element, spot.offset, block);\n          var results_1 = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          var pos = results_1.position;\n          var start = findPatternStart(dom, pattern, pos.element, pos.offset, block, resultsOpt.isNone());\n          return start.map(function (startRng) {\n            var startPathRng = generatePathRangeFromRange(root, startRng);\n            return {\n              matches: results_1.matches.concat([{\n                  pattern: pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    var findPatternsRec = function (editor, patterns, node, offset, block) {\n      var dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(function (endSpot) {\n        var rng = dom.createRng();\n        rng.setStart(block, 0);\n        rng.setEnd(node, offset);\n        var text = rng.toString();\n        for (var i = 0; i < patterns.length; i++) {\n          var pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          var patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          var result = findPattern$1(editor, block, {\n            pattern: pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          });\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Option.none();\n      });\n    };\n    var applyPattern$1 = function (editor, pattern, patternRange) {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each(pattern.format, function (format) {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    var applyReplacementPattern = function (editor, pattern, marker, isRoot) {\n      var markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern$1(editor, pattern, markerRange);\n    };\n    var applyPatternWithContent = function (editor, pattern, startMarker, endMarker, isRoot) {\n      var dom = editor.dom;\n      var markerEndRange = rangeFromMarker(dom, endMarker);\n      var markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      var patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      var patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern$1(editor, pattern, patternRange);\n    };\n    var addMarkers = function (dom, matches) {\n      var markerPrefix = generate$1('mce_textpattern');\n      var matchesWithEnds = foldr(matches, function (acc, match) {\n        var endMarker = createMarker(dom, markerPrefix + ('_end' + acc.length), match.endRng);\n        return acc.concat([__assign(__assign({}, match), { endMarker: endMarker })]);\n      }, []);\n      return foldr(matchesWithEnds, function (acc, match) {\n        var idx = matchesWithEnds.length - acc.length - 1;\n        var startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + ('_start' + idx), match.startRng);\n        return acc.concat([__assign(__assign({}, match), { startMarker: startMarker })]);\n      }, []);\n    };\n    var findPatterns$1 = function (editor, patterns, space) {\n      var rng = editor.selection.getRng();\n      if (rng.collapsed === false) {\n        return [];\n      }\n      return getParentBlock(editor, rng).bind(function (block) {\n        var offset = rng.startOffset - (space ? 1 : 0);\n        return findPatternsRec(editor, patterns, rng.startContainer, offset, block);\n      }).fold(function () {\n        return [];\n      }, function (result) {\n        return result.matches;\n      });\n    };\n    var applyMatches$1 = function (editor, matches) {\n      if (matches.length === 0) {\n        return;\n      }\n      var dom = editor.dom;\n      var bookmark = editor.selection.getBookmark();\n      var matchesWithMarkers = addMarkers(dom, matches);\n      each(matchesWithMarkers, function (match) {\n        var block = dom.getParent(match.startMarker.start, dom.isBlock);\n        var isRoot = function (node) {\n          return node === block;\n        };\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    var handleEnter = function (editor, patternSet) {\n      if (!editor.selection.isCollapsed()) {\n        return false;\n      }\n      var inlineMatches = findPatterns$1(editor, patternSet.inlinePatterns, false);\n      var blockMatches = findPatterns(editor, patternSet.blockPatterns);\n      if (blockMatches.length > 0 || inlineMatches.length > 0) {\n        editor.undoManager.add();\n        editor.undoManager.extra(function () {\n          editor.execCommand('mceInsertNewLine');\n        }, function () {\n          editor.insertContent(zeroWidth());\n          applyMatches$1(editor, inlineMatches);\n          applyMatches(editor, blockMatches);\n          var range = editor.selection.getRng();\n          var spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n          editor.execCommand('mceInsertNewLine');\n          spot.each(function (s) {\n            if (s.element.data.charAt(s.offset - 1) === zeroWidth()) {\n              s.element.deleteData(s.offset - 1, 1);\n              cleanEmptyNodes(editor.dom, s.element.parentNode, function (e) {\n                return e === editor.dom.getRoot();\n              });\n            }\n          });\n        });\n        return true;\n      }\n      return false;\n    };\n    var handleInlineKey = function (editor, patternSet) {\n      var inlineMatches = findPatterns$1(editor, patternSet.inlinePatterns, true);\n      if (inlineMatches.length > 0) {\n        editor.undoManager.transact(function () {\n          applyMatches$1(editor, inlineMatches);\n        });\n      }\n    };\n    var checkKeyEvent = function (codes, event, predicate) {\n      for (var i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n    };\n    var checkKeyCode = function (codes, event) {\n      return checkKeyEvent(codes, event, function (code, event) {\n        return code === event.keyCode && global$2.modifierPressed(event) === false;\n      });\n    };\n    var checkCharCode = function (chars, event) {\n      return checkKeyEvent(chars, event, function (chr, event) {\n        return chr.charCodeAt(0) === event.charCode;\n      });\n    };\n    var KeyHandler = {\n      handleEnter: handleEnter,\n      handleInlineKey: handleInlineKey,\n      checkCharCode: checkCharCode,\n      checkKeyCode: checkKeyCode\n    };\n\n    var setup = function (editor, patternsState) {\n      var charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      var keyCodes = [32];\n      editor.on('keydown', function (e) {\n        if (e.keyCode === 13 && !global$2.modifierPressed(e)) {\n          if (KeyHandler.handleEnter(editor, patternsState.get())) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      editor.on('keyup', function (e) {\n        if (KeyHandler.checkKeyCode(keyCodes, e)) {\n          KeyHandler.handleInlineKey(editor, patternsState.get());\n        }\n      });\n      editor.on('keypress', function (e) {\n        if (KeyHandler.checkCharCode(charCodes, e)) {\n          global$1.setEditorTimeout(editor, function () {\n            KeyHandler.handleInlineKey(editor, patternsState.get());\n          });\n        }\n      });\n    };\n    var Keyboard = { setup: setup };\n\n    function Plugin () {\n      global.add('textpattern', function (editor) {\n        var patternsState = Cell(getPatternSet(editor.settings));\n        Keyboard.setup(editor, patternsState);\n        return Api.get(patternsState);\n      });\n    }\n\n    Plugin();\n\n}(window));\n"]}