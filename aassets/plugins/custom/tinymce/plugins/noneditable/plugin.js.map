{"version":3,"sources":["noneditable/plugin.js"],"names":["global","tinymce","util","Tools","resolve","global$1","Settings","editor","getParam","nonEditableRegExps","constructor","RegExp","hasClass","checkClassName","node","attr","indexOf","replaceMatchWithSpan","content","cls","match","args","arguments","index","length","prevChar","charAt","findStartTagIndex","lastIndexOf","substring","dom","encode","FilterContent","setup","editClass","nonEditClass","trim","hasEditClass","hasNonEditClass","on","e","i","format","replace","convertRegExpsToNonEditable","parser","addAttributeFilter","nodes","serializer","name","type","raw","value","add"],"mappings":"CAQC,WACG,aAEA,IAAIA,EAASC,QAAQC,KAAKC,MAAMC,QAAQ,yBAEpCC,EAAWJ,QAAQC,KAAKC,MAAMC,QAAQ,sBAgBtCE,EAdsB,SAAUC,GAClC,OAAOA,EAAOC,SAAS,gCAAiC,mBAatDF,EAXmB,SAAUC,GAC/B,OAAOA,EAAOC,SAAS,6BAA8B,gBAUnDF,EARwB,SAAUC,GACpC,IAAIE,EAAqBF,EAAOC,SAAS,qBAAsB,IAC/D,OAAIC,GAAsBA,EAAmBC,cAAgBC,OACpD,CAACF,GAEDA,GASPG,EAAW,SAAUC,GACvB,OAAO,SAAUC,GACf,OAAqE,KAA7D,IAAMA,EAAKC,KAAK,SAAW,KAAKC,QAAQH,KAGhDI,EAAuB,SAAUV,EAAQW,EAASC,GACpD,OAAO,SAAUC,GACf,IAAIC,EAAOC,UAAWC,EAAQF,EAAKA,EAAKG,OAAS,GAC7CC,EAAWF,EAAQ,EAAIL,EAAQQ,OAAOH,EAAQ,GAAK,GACvD,GAAiB,MAAbE,EACF,OAAOL,EAET,GAAiB,MAAbK,EAAkB,CACpB,IAAIE,EAAoBT,EAAQU,YAAY,IAAKL,GACjD,IAA2B,IAAvBI,EAEF,IAAoD,IADtCT,EAAQW,UAAUF,EAAmBJ,GACvCP,QAAQ,2BAClB,OAAOI,EAIb,MAAO,gBAAkBD,EAAM,uBAAyBZ,EAAOuB,IAAIC,OAAOV,EAAK,IAAM,KAAOd,EAAOuB,IAAIC,OAA0B,iBAAZV,EAAK,GAAkBA,EAAK,GAAKA,EAAK,IAAM,YAyDjKW,EAAgB,CAAEC,MA5CV,SAAU1B,GACpB,IAAI2B,EAAWC,EAEfD,EAAY,IAAM7B,EAAS+B,KAAK9B,EAA0BC,IAAW,IACrE4B,EAAe,IAAM9B,EAAS+B,KAAK9B,EAA6BC,IAAW,IAC3E,IAAI8B,EAAezB,EAASsB,GACxBI,EAAkB1B,EAASuB,GAC3B1B,EAAqBH,EAA+BC,GACxDA,EAAOgC,GAAG,UAAW,WACf9B,EAAmBe,OAAS,GAC9BjB,EAAOgC,GAAG,mBAAoB,SAAUC,IApBZ,SAAUjC,EAAQE,EAAoB+B,GACtE,IAAIC,EAAIhC,EAAmBe,OAAQN,EAAUsB,EAAEtB,QAC/C,GAAiB,QAAbsB,EAAEE,OAAN,CAGA,KAAOD,KACLvB,EAAUA,EAAQyB,QAAQlC,EAAmBgC,GAAIxB,EAAqBV,EAAQW,EAASZ,EAA6BC,KAEtHiC,EAAEtB,QAAUA,GAaN0B,CAA4BrC,EAAQE,EAAoB+B,KAG5DjC,EAAOsC,OAAOC,mBAAmB,QAAS,SAAUC,GAElD,IADA,IAAsBjC,EAAlB2B,EAAIM,EAAMvB,OACPiB,KACL3B,EAAOiC,EAAMN,GACTJ,EAAavB,GACfA,EAAKC,KAjBiB,kBAiBa,QAC1BuB,EAAgBxB,IACzBA,EAAKC,KAnBiB,kBAmBa,WAIzCR,EAAOyC,WAAWF,mBAvBU,kBAuBkC,SAAUC,GAEtE,IADA,IAAsBjC,EAAlB2B,EAAIM,EAAMvB,OACPiB,KACL3B,EAAOiC,EAAMN,IACRJ,EAAavB,IAAUwB,EAAgBxB,MAGxCL,EAAmBe,OAAS,GAAKV,EAAKC,KAAK,qBAC7CD,EAAKmC,KAAO,QACZnC,EAAKoC,KAAO,EACZpC,EAAKqC,KAAM,EACXrC,EAAKsC,MAAQtC,EAAKC,KAAK,qBAEvBD,EAAKC,KApCiB,kBAoCa,aAS3Cf,EAAOqD,IAAI,cAAe,SAAU9C,GAClCyB,EAAcC,MAAM1B,KA7G5B","file":"plugin.js","sourcesContent":["/**\n * Copyright (c) Tiny Technologies, Inc. All rights reserved.\n * Licensed under the LGPL or a commercial license.\n * For LGPL see License.txt in the project root for license information.\n * For commercial licenses see https://www.tiny.cloud/\n *\n * Version: 5.1.0 (2019-10-17)\n */\n(function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    var getNonEditableClass = function (editor) {\n      return editor.getParam('noneditable_noneditable_class', 'mceNonEditable');\n    };\n    var getEditableClass = function (editor) {\n      return editor.getParam('noneditable_editable_class', 'mceEditable');\n    };\n    var getNonEditableRegExps = function (editor) {\n      var nonEditableRegExps = editor.getParam('noneditable_regexp', []);\n      if (nonEditableRegExps && nonEditableRegExps.constructor === RegExp) {\n        return [nonEditableRegExps];\n      } else {\n        return nonEditableRegExps;\n      }\n    };\n    var Settings = {\n      getNonEditableClass: getNonEditableClass,\n      getEditableClass: getEditableClass,\n      getNonEditableRegExps: getNonEditableRegExps\n    };\n\n    var hasClass = function (checkClassName) {\n      return function (node) {\n        return (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n      };\n    };\n    var replaceMatchWithSpan = function (editor, content, cls) {\n      return function (match) {\n        var args = arguments, index = args[args.length - 2];\n        var prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          var findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            var tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    var convertRegExpsToNonEditable = function (editor, nonEditableRegExps, e) {\n      var i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, Settings.getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    var setup = function (editor) {\n      var editClass, nonEditClass;\n      var contentEditableAttrName = 'contenteditable';\n      editClass = ' ' + global$1.trim(Settings.getEditableClass(editor)) + ' ';\n      nonEditClass = ' ' + global$1.trim(Settings.getNonEditableClass(editor)) + ' ';\n      var hasEditClass = hasClass(editClass);\n      var hasNonEditClass = hasClass(nonEditClass);\n      var nonEditableRegExps = Settings.getNonEditableRegExps(editor);\n      editor.on('PreInit', function () {\n        if (nonEditableRegExps.length > 0) {\n          editor.on('BeforeSetContent', function (e) {\n            convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n          });\n        }\n        editor.parser.addAttributeFilter('class', function (nodes) {\n          var i = nodes.length, node;\n          while (i--) {\n            node = nodes[i];\n            if (hasEditClass(node)) {\n              node.attr(contentEditableAttrName, 'true');\n            } else if (hasNonEditClass(node)) {\n              node.attr(contentEditableAttrName, 'false');\n            }\n          }\n        });\n        editor.serializer.addAttributeFilter(contentEditableAttrName, function (nodes) {\n          var i = nodes.length, node;\n          while (i--) {\n            node = nodes[i];\n            if (!hasEditClass(node) && !hasNonEditClass(node)) {\n              continue;\n            }\n            if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n              node.name = '#text';\n              node.type = 3;\n              node.raw = true;\n              node.value = node.attr('data-mce-content');\n            } else {\n              node.attr(contentEditableAttrName, null);\n            }\n          }\n        });\n      });\n    };\n    var FilterContent = { setup: setup };\n\n    function Plugin () {\n      global.add('noneditable', function (editor) {\n        FilterContent.setup(editor);\n      });\n    }\n\n    Plugin();\n\n}());\n"]}